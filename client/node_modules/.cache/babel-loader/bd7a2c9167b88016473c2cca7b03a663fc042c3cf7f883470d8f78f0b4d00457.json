{"ast":null,"code":"// src/modules/reservas/reservas.controller.js\nconst mongoose = require('mongoose');\nconst Reserva = require('./reservas.model');\nconst Habitacion = mongoose.model('Habitacion');\nconst checkAvailability = async (habitacion_id, fecha_inicio, fecha_fin, excludeReservaId = null) => {\n  const query = {\n    habitacion_id: habitacion_id,\n    estado: 'Confirmado',\n    $or: [{\n      fecha_inicio: {\n        $lt: fecha_fin\n      },\n      fecha_fin: {\n        $gt: fecha_inicio\n      }\n    }]\n  };\n  if (excludeReservaId) {\n    query._id = {\n      $ne: excludeReservaId\n    };\n  }\n  const existingReservation = await Reserva.findOne(query);\n  return !existingReservation;\n};\nexports.createReserva = async (req, res, next) => {\n  req.body.cliente_id = req.user.id;\n  const {\n    habitacion_id,\n    fecha_inicio,\n    fecha_fin\n  } = req.body;\n  try {\n    const isAvailable = await checkAvailability(habitacion_id, fecha_inicio, fecha_fin);\n    if (!isAvailable) return res.status(409).json({\n      success: false,\n      message: 'Conflicto: La habitación ya se encuentra reservada para las fechas seleccionadas.'\n    });\n    const habitacion = await Habitacion.findById(habitacion_id);\n    if (!habitacion) return res.status(404).json({\n      message: 'Habitación no encontrada.'\n    });\n    const dias = (new Date(fecha_fin) - new Date(fecha_inicio)) / (1000 * 60 * 60 * 24);\n    if (dias <= 0) return res.status(400).json({\n      message: 'La fecha de fin debe ser posterior a la fecha de inicio.'\n    });\n    req.body.precio_final = dias * habitacion.precio;\n    const reserva = await Reserva.create(req.body);\n    res.status(201).json({\n      success: true,\n      data: reserva\n    });\n  } catch (error) {\n    next(error);\n  }\n};\nexports.createReservaAdmin = async (req, res, next) => {\n  const {\n    cliente_id,\n    habitacion_id,\n    fecha_inicio,\n    fecha_fin,\n    estado\n  } = req.body;\n  try {\n    const isAvailable = await checkAvailability(habitacion_id, fecha_inicio, fecha_fin);\n    if (!isAvailable) return res.status(409).json({\n      success: false,\n      message: 'Conflicto: La habitación ya se encuentra reservada para las fechas seleccionadas.'\n    });\n    const habitacion = await Habitacion.findById(habitacion_id);\n    if (!habitacion) return res.status(404).json({\n      message: 'Habitación no encontrada.'\n    });\n    const dias = (new Date(fecha_fin) - new Date(fecha_inicio)) / (1000 * 60 * 60 * 24);\n    if (dias <= 0) return res.status(400).json({\n      message: 'La fecha de fin debe ser posterior a la fecha de inicio.'\n    });\n    const precio_final = dias * habitacion.precio;\n    const reserva = await Reserva.create({\n      cliente_id,\n      habitacion_id,\n      fecha_inicio,\n      fecha_fin,\n      estado,\n      precio_final\n    });\n    res.status(201).json({\n      success: true,\n      data: reserva\n    });\n  } catch (error) {\n    next(error);\n  }\n};\nexports.getMisReservas = async (req, res, next) => {\n  try {\n    const reservas = await Reserva.find({\n      cliente_id: req.user.id\n    }).populate('habitacion_id', 'nombre precio');\n    res.status(200).json({\n      success: true,\n      data: reservas\n    });\n  } catch (error) {\n    next(error);\n  }\n};\nexports.findAvailableRooms = async (req, res, next) => {\n  const {\n    fecha_inicio,\n    fecha_fin\n  } = req.query;\n  if (!fecha_inicio || !fecha_fin) return res.status(400).json({\n    message: 'Las fechas de inicio y fin son requeridas.'\n  });\n  try {\n    const conflictingReservations = await Reserva.find({\n      estado: 'Confirmado',\n      $or: [{\n        fecha_inicio: {\n          $lt: fecha_fin\n        },\n        fecha_fin: {\n          $gt: fecha_inicio\n        }\n      }]\n    }).select('habitacion_id');\n    const conflictingRoomIds = conflictingReservations.map(reserva => reserva.habitacion_id);\n    const availableRooms = await Habitacion.find({\n      _id: {\n        $nin: conflictingRoomIds\n      }\n    });\n    res.status(200).json({\n      success: true,\n      count: availableRooms.length,\n      data: availableRooms\n    });\n  } catch (error) {\n    next(error);\n  }\n};\nexports.getAllReservasAdmin = async (req, res, next) => {\n  try {\n    // --- CAMBIO CLAVE AQUÍ ---\n    // Ahora, al popular 'habitacion_id', también traemos el campo 'precio'.\n    const reservas = await Reserva.find().sort({\n      createdAt: -1\n    }).populate('cliente_id', 'nombre email _id').populate('habitacion_id', 'nombre precio'); // Se añade 'precio'\n\n    res.status(200).json({\n      success: true,\n      count: reservas.length,\n      data: reservas\n    });\n  } catch (error) {\n    next(error);\n  }\n};\nexports.updateReservaAdmin = async (req, res, next) => {\n  try {\n    // Si se actualiza la reserva, podría ser necesario recalcular el precio\n    if (req.body.fecha_inicio && req.body.fecha_fin && req.body.habitacion_id) {\n      const habitacion = await Habitacion.findById(req.body.habitacion_id);\n      const dias = (new Date(req.body.fecha_fin) - new Date(req.body.fecha_inicio)) / (1000 * 60 * 60 * 24);\n      req.body.precio_final = dias * habitacion.precio;\n    }\n    const reserva = await Reserva.findByIdAndUpdate(req.params.id, req.body, {\n      new: true,\n      runValidators: true\n    });\n    if (!reserva) return res.status(404).json({\n      success: false,\n      message: 'Reserva no encontrada'\n    });\n    res.status(200).json({\n      success: true,\n      data: reserva\n    });\n  } catch (error) {\n    next(error);\n  }\n};\nexports.deleteReservaAdmin = async (req, res, next) => {\n  try {\n    const reserva = await Reserva.findByIdAndDelete(req.params.id);\n    if (!reserva) return res.status(404).json({\n      success: false,\n      message: 'Reserva no encontrada'\n    });\n    res.status(200).json({\n      success: true,\n      data: {}\n    });\n  } catch (error) {\n    next(error);\n  }\n};","map":{"version":3,"names":["mongoose","require","Reserva","Habitacion","model","checkAvailability","habitacion_id","fecha_inicio","fecha_fin","excludeReservaId","query","estado","$or","$lt","$gt","_id","$ne","existingReservation","findOne","exports","createReserva","req","res","next","body","cliente_id","user","id","isAvailable","status","json","success","message","habitacion","findById","dias","Date","precio_final","precio","reserva","create","data","error","createReservaAdmin","getMisReservas","reservas","find","populate","findAvailableRooms","conflictingReservations","select","conflictingRoomIds","map","availableRooms","$nin","count","length","getAllReservasAdmin","sort","createdAt","updateReservaAdmin","findByIdAndUpdate","params","new","runValidators","deleteReservaAdmin","findByIdAndDelete"],"sources":["C:/Users/David/Desktop/veranum-system/client/src/pages/ManageReservasPage.jsx"],"sourcesContent":["// src/modules/reservas/reservas.controller.js\r\nconst mongoose = require('mongoose');\r\nconst Reserva = require('./reservas.model');\r\nconst Habitacion = mongoose.model('Habitacion');\r\n\r\nconst checkAvailability = async (habitacion_id, fecha_inicio, fecha_fin, excludeReservaId = null) => {\r\n    const query = {\r\n        habitacion_id: habitacion_id,\r\n        estado: 'Confirmado',\r\n        $or: [ { fecha_inicio: { $lt: fecha_fin }, fecha_fin: { $gt: fecha_inicio } } ]\r\n    };\r\n    if (excludeReservaId) {\r\n        query._id = { $ne: excludeReservaId };\r\n    }\r\n    const existingReservation = await Reserva.findOne(query);\r\n    return !existingReservation;\r\n};\r\n\r\nexports.createReserva = async (req, res, next) => {\r\n    req.body.cliente_id = req.user.id;\r\n    const { habitacion_id, fecha_inicio, fecha_fin } = req.body;\r\n    try {\r\n        const isAvailable = await checkAvailability(habitacion_id, fecha_inicio, fecha_fin);\r\n        if (!isAvailable) return res.status(409).json({ success: false, message: 'Conflicto: La habitación ya se encuentra reservada para las fechas seleccionadas.' });\r\n        \r\n        const habitacion = await Habitacion.findById(habitacion_id);\r\n        if (!habitacion) return res.status(404).json({ message: 'Habitación no encontrada.' });\r\n        \r\n        const dias = (new Date(fecha_fin) - new Date(fecha_inicio)) / (1000 * 60 * 60 * 24);\r\n        if (dias <= 0) return res.status(400).json({ message: 'La fecha de fin debe ser posterior a la fecha de inicio.'});\r\n        \r\n        req.body.precio_final = dias * habitacion.precio;\r\n        const reserva = await Reserva.create(req.body);\r\n        res.status(201).json({ success: true, data: reserva });\r\n    } catch (error) {\r\n        next(error);\r\n    }\r\n};\r\n\r\nexports.createReservaAdmin = async (req, res, next) => {\r\n    const { cliente_id, habitacion_id, fecha_inicio, fecha_fin, estado } = req.body;\r\n    try {\r\n        const isAvailable = await checkAvailability(habitacion_id, fecha_inicio, fecha_fin);\r\n        if (!isAvailable) return res.status(409).json({ success: false, message: 'Conflicto: La habitación ya se encuentra reservada para las fechas seleccionadas.' });\r\n        \r\n        const habitacion = await Habitacion.findById(habitacion_id);\r\n        if (!habitacion) return res.status(404).json({ message: 'Habitación no encontrada.' });\r\n\r\n        const dias = (new Date(fecha_fin) - new Date(fecha_inicio)) / (1000 * 60 * 60 * 24);\r\n        if (dias <= 0) return res.status(400).json({ message: 'La fecha de fin debe ser posterior a la fecha de inicio.'});\r\n        \r\n        const precio_final = dias * habitacion.precio;\r\n        const reserva = await Reserva.create({ cliente_id, habitacion_id, fecha_inicio, fecha_fin, estado, precio_final });\r\n        res.status(201).json({ success: true, data: reserva });\r\n    } catch (error) {\r\n        next(error);\r\n    }\r\n};\r\n\r\nexports.getMisReservas = async (req, res, next) => {\r\n    try {\r\n        const reservas = await Reserva.find({ cliente_id: req.user.id }).populate('habitacion_id', 'nombre precio');\r\n        res.status(200).json({ success: true, data: reservas });\r\n    } catch (error) { next(error); }\r\n};\r\n\r\nexports.findAvailableRooms = async (req, res, next) => {\r\n    const { fecha_inicio, fecha_fin } = req.query;\r\n    if (!fecha_inicio || !fecha_fin) return res.status(400).json({ message: 'Las fechas de inicio y fin son requeridas.' });\r\n    try {\r\n        const conflictingReservations = await Reserva.find({ \r\n            estado: 'Confirmado',\r\n            $or: [ { fecha_inicio: { $lt: fecha_fin }, fecha_fin: { $gt: fecha_inicio } } ] \r\n        }).select('habitacion_id');\r\n        \r\n        const conflictingRoomIds = conflictingReservations.map(reserva => reserva.habitacion_id);\r\n        const availableRooms = await Habitacion.find({ _id: { $nin: conflictingRoomIds } });\r\n        res.status(200).json({ success: true, count: availableRooms.length, data: availableRooms });\r\n    } catch (error) { next(error); }\r\n};\r\n\r\nexports.getAllReservasAdmin = async (req, res, next) => {\r\n    try {\r\n        // --- CAMBIO CLAVE AQUÍ ---\r\n        // Ahora, al popular 'habitacion_id', también traemos el campo 'precio'.\r\n        const reservas = await Reserva.find()\r\n            .sort({ createdAt: -1 })\r\n            .populate('cliente_id', 'nombre email _id')\r\n            .populate('habitacion_id', 'nombre precio'); // Se añade 'precio'\r\n            \r\n        res.status(200).json({ success: true, count: reservas.length, data: reservas });\r\n    } catch (error) {\r\n        next(error);\r\n    }\r\n};\r\n\r\nexports.updateReservaAdmin = async (req, res, next) => {\r\n    try {\r\n        // Si se actualiza la reserva, podría ser necesario recalcular el precio\r\n        if (req.body.fecha_inicio && req.body.fecha_fin && req.body.habitacion_id) {\r\n            const habitacion = await Habitacion.findById(req.body.habitacion_id);\r\n            const dias = (new Date(req.body.fecha_fin) - new Date(req.body.fecha_inicio)) / (1000 * 60 * 60 * 24);\r\n            req.body.precio_final = dias * habitacion.precio;\r\n        }\r\n        const reserva = await Reserva.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });\r\n        if (!reserva) return res.status(404).json({ success: false, message: 'Reserva no encontrada' });\r\n        res.status(200).json({ success: true, data: reserva });\r\n    } catch (error) { next(error); }\r\n};\r\n\r\nexports.deleteReservaAdmin = async (req, res, next) => {\r\n    try {\r\n        const reserva = await Reserva.findByIdAndDelete(req.params.id);\r\n        if (!reserva) return res.status(404).json({ success: false, message: 'Reserva no encontrada' });\r\n        res.status(200).json({ success: true, data: {} });\r\n    } catch (error) { next(error); }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}